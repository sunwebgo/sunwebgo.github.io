

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/favicon.png">
  <link rel="icon" href="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Xu huaiang">
  <meta name="keywords" content="">
  
    <meta name="description" content="&#x3D;&#x3D;索引是存储引擎用于快速找到数据记录的一种数据结构&#x3D;&#x3D;，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。  如上图所示，数据库没有索引的情">
<meta property="og:type" content="article">
<meta property="og:title" content="第06章_索引的数据结构">
<meta property="og:url" content="https://xhablog.online/2021/04/19/MySQL%E9%AB%98%E7%BA%A7-%E7%AC%AC06%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="xhang′s blog">
<meta property="og:description" content="&#x3D;&#x3D;索引是存储引擎用于快速找到数据记录的一种数据结构&#x3D;&#x3D;，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。  如上图所示，数据库没有索引的情">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/image-20230412151501213.png">
<meta property="article:published_time" content="2021-04-19T08:00:00.000Z">
<meta property="article:modified_time" content="2023-06-15T04:59:50.737Z">
<meta property="article:author" content="Xu huaiang">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/image-20230412151501213.png">
  
  
  
  <title>第06章_索引的数据结构 - xhang′s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/iconfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xhablog.online","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"giycfQfOF4KRyAqEJy6tocBG-gzGzoHsz","app_key":"eFPJSGrHpiDV2uq6UTxse15b","server_url":"https://giycfqfo.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>xhang′s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-zhuye"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-guidang1"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-fenlei"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-biaoqian"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/messageboard/">
                <i class="iconfont icon-liuyanban-05"></i>
                <span>留言板</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-youqinglianjie"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-guanyuwomen"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/index.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第06章_索引的数据结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Xu huaiang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-04-19 16:00" pubdate>
          2021年4月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          170 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第06章_索引的数据结构</h1>
            
            
              <div class="markdown-body">
                
                <p>&#x3D;&#x3D;索引是存储引擎用于快速找到数据记录的一种数据结构&#x3D;&#x3D;，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413220603612.png" srcset="/img/loading.gif" lazyload alt="image-20230413220603612"></p>
<p>如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从Col 2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/O</code>才能找到。现在要查找 Col 2 &#x3D; 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I&#x2F;O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）。</p>
<p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413221018074.png" srcset="/img/loading.gif" lazyload alt="image-20230413221018074"></p>
<p>对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 <code>二叉搜索树</code>。二叉搜索树的每个结点存储的是 <code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89&#x3D;&#x3D;89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 <code>查找两次</code> 就可以定位到记录的地址，查询速度就提高了。</p>
<p>&#x3D;&#x3D;这就是我们为什么要建索引，目的就是为了 <code>减少磁盘I/O的次数</code>，加快查询速率。&#x3D;&#x3D;</p>
<h2 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2. 索引及其优缺点"></a>2. 索引及其优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p>MySQL官方对索引的定义为：&#x3D;&#x3D;<strong><font color='red'>索引（Index）是帮助MySQL高效获取数据的数据结构。</font></strong>&#x3D;&#x3D;</p>
<p><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。</p>
<p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code>和 <code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><blockquote>
<ul>
<li>提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。</li>
<li>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。</li>
</ul>
</blockquote>
<h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<blockquote>
<ul>
<li>创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</li>
</ul>
</blockquote>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3. InnoDB中索引的推演"></a>3. InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span>列名列表<span class="token punctuation">]</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 列名 <span class="token operator">=</span> xxx<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h4 id="1-在一个页中的查找"><a href="#1-在一个页中的查找" class="headerlink" title="1. 在一个页中的查找"></a>1. 在一个页中的查找</h4><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li><p><strong>以主键为搜索条件</strong></p>
<p>可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p>
</li>
<li><p><strong>以其他列作为搜索条件</strong></p>
<p>因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。<font color='red'>这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</font></p>
</li>
</ul>
<h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2. 在很多页中查找"></a>2. 在很多页中查找</h4><p>在很多页中查找记录的活动可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 <code>从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。</code>因为要遍历所有的数据页，所以这种方式显然是<font color='red'>超级耗时</font>的。如果一个表有一亿条记录呢？此时<code>索引</code>应运而生。</p>
<h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><p>建一个表：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo<span class="token punctuation">(</span>
<span class="token operator">-</span><span class="token operator">></span> c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>
<span class="token operator">-</span><span class="token operator">></span> c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
<span class="token operator">-</span><span class="token operator">></span> c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">)</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>这个新建的 <code>**index_demo** </code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用<code> **Compact** 行格式</code>来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413221030831.png" srcset="/img/loading.gif" lazyload alt="image-20230413221030831"></p>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li><code>record_type</code> ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li>
<li><code>next_record </code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。</li>
<li><code>各个列的值</code> ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li>
<li><code>其他信息</code> ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224633751.png" srcset="/img/loading.gif" lazyload alt="image-20230413224633751"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224651435.png" srcset="/img/loading.gif" lazyload alt="image-20230413224651435"></p>
<h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>&#x3D;&#x3D;我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。&#x3D;&#x3D;所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？&#x3D;&#x3D;我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：&#x3D;&#x3D;</p>
<ul>
<li><p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<p>假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li>
</ul>
<p>那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224703375.png" srcset="/img/loading.gif" lazyload alt="image-20230413224703375"></p>
<p>从图中可以看出来， <code>index_demo</code> 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> index_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>因为 <strong>页10</strong> 最多只能放3条记录，所以我们不得不再分配一个新页：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224712000.png" srcset="/img/loading.gif" lazyload alt="image-20230413224712000"></p>
<p>注意：新分配的 <strong>数据页编号可能并不是连续的</strong>。它们只是通过维护者上一个页和下一个页的编号而建立了 <strong>链表</strong> 关系。另外，<font color='red'><strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求</font>，所以在插入主键值为4的记录的时候需要伴随着一次 <code>记录移动</code>，&#x3D;&#x3D;也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：&#x3D;&#x3D;</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224725768.png" srcset="/img/loading.gif" lazyload alt="image-20230413224725768"></p>
<p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 <strong>记录移动</strong> 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 <strong>页分裂</strong>。</p>
<ul>
<li><strong>给所有的页建立一个<code>目录项</code>。</strong></li>
</ul>
<p>由于数据页的 <strong><code>编号可能是不连续</code></strong> 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224732895.png" srcset="/img/loading.gif" lazyload alt="image-20230413224732895"></p>
<p>我们需要给它们做个 **<code>目录</code>**，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<p>1）页的用户记录中最小的主键值，我们用 <strong><code>key</code></strong> 来表示。</p>
<p>2）页号，我们用 <strong><code>page_on</code></strong> 表示。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224743506.png" srcset="/img/loading.gif" lazyload alt="image-20230413224743506"></p>
<p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。</li>
<li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li>
</ol>
<p><strong><font color='red'>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 索引 。</font></strong></p>
<h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①-迭代1次：目录项纪录的页"><a href="#①-迭代1次：目录项纪录的页" class="headerlink" title="① 迭代1次：目录项纪录的页"></a>① 迭代1次：目录项纪录的页</h5><p>InnoDB怎么区分一条记录是普通的 <strong>用户记录</strong> 还是 <strong>目录项记录</strong> 呢？使用记录头信息里的 <strong>record_type</strong> 属性，它的各自取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>我们把前边使用到的目录项组成<code>目录页</code>，放到<code>数据页</code>中的样子就是这样：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224754194.png" srcset="/img/loading.gif" lazyload alt="image-20230413224754194"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong><code>目录项记录</code></strong> 和普通的 <strong><code>用户记录</code></strong> 的不同点：</p>
<ul>
<li>&#x3D;&#x3D;<strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的&#x3D;&#x3D;，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。</li>
</ul>
<p><strong>相同点</strong>：&#x3D;&#x3D;两者用的是一样的数据页，都会为主键值生成 **<code>Page Directory （页目录）</code>**，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。&#x3D;&#x3D;</p>
<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li>
<li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</li>
</ol>
<h5 id="②-迭代2次：多个目录项纪录的页"><a href="#②-迭代2次：多个目录项纪录的页" class="headerlink" title="② 迭代2次：多个目录项纪录的页"></a>② 迭代2次：多个目录项纪录的页</h5><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的目录项记录也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的<br>目录项记录，如何处理呢?</p>
<p>这里我们假设一个存储目录项记录的页最多只能存放4条目录项记录，所以如果此时我们再向.上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页:</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224804728.png" srcset="/img/loading.gif" lazyload alt="image-20230413224804728"></p>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了 页31 。</li>
<li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得不需要一个新的目录页32 来存放 页31 对应的数据项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p>
<ol>
<li>确定目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。</li>
<li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<h5 id="③-迭代3次：目录项记录页的目录页"><a href="#③-迭代3次：目录项记录页的目录页" class="headerlink" title="③ 迭代3次：目录项记录页的目录页"></a>③ 迭代3次：目录项记录页的目录页</h5><p>如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224818366.png" srcset="/img/loading.gif" lazyload alt="image-20230413224818366"></p>
<p>&#x3D;&#x3D;如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。&#x3D;&#x3D;</p>
<p>我们可以用下边这个图来描述它：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224828673.png" srcset="/img/loading.gif" lazyload alt="image-20230413224828673"></p>
<p>这个数据结构，它的名称是 B+树 。</p>
<h5 id="④-B-Tree"><a href="#④-B-Tree" class="headerlink" title="④ B+Tree"></a>④ B+Tree</h5><p>不论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页,我们都把它们存放到B+树这个数据结构中了,所以我们也称这些数据页为节点。从图中可以看出，&#x3D;&#x3D;我们的实际用户记录其实都存放在B+树的最底层的节点上，即<code>数据页</code>，这些节点也被称为叶子节点，其余用来存放目录项的节点称为非叶子节点或者内节点，就是所谓的<code>目录页</code>，其中B+树最.上边的那个节点也称为根节点。&#x3D;&#x3D;</p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</li>
<li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</li>
<li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li>
</ul>
<p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们用到的 <strong>B+树都不会超过4层</strong> ，&#x3D;&#x3D;那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速 定位记录。&#x3D;&#x3D;</p>
<h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。</p>
<h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是<strong>基于主键一种数据存储方式</strong>（<font color='red'>所有的用户记录都存储在了叶子结点</font>），也就是所谓的 <code>索引即数据，数据即索引</code>。</p>
<blockquote>
<p>术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><p>&#x3D;&#x3D;使用记录主键值的大小进行记录和页的排序&#x3D;&#x3D;，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。</li>
<li>各个存放 <code>用户记录的页(数据页)</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
<li>存放 <code>目录项记录的页(目录页)</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;B+树的 叶子节点 存储的是完整的用户记录&#x3D;&#x3D;。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ul>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<code>INDEX</code> 语句去创建， <code>InnDB</code> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。</p>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code> 。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
<li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p><strong>限制:</strong></p>
<ul>
<li>对于MySQL数据库目前只有<code>InnoDB</code>数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li>
<li>由于数据物理存储排序方式只能有一种，&#x3D;&#x3D;所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。&#x3D;&#x3D;</li>
<li><font color='orange'>如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。</font></li>
<li><font color='red'>为了充分利用聚簇索引的聚簇的特性,所以innodb表的主键列尽量选用有序的顺序id,而不建议用无序的id，比如UUID、MD5、 HASH、 字符串列作为主键无法保证数据的顺序增长。</font></li>
</ul>
</blockquote>
<h4 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h4><p><font color='red'>如果我们想以主键之外的列作为搜索条件该怎么办</font>？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224840017.png" srcset="/img/loading.gif" lazyload alt="image-20230413224840017"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224853773.png" srcset="/img/loading.gif" lazyload alt="image-20230413224853773"></p>
<p>**概念：回表 **</p>
<p>&#x3D;&#x3D;我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。&#x3D;&#x3D;也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>问题</strong>：为什么我们还需要一次 <code>回表</code> 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<p><strong>回答</strong>：</p>
<p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，<font color='red'>相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</font></p>
<p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。</p>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224904495.png" srcset="/img/loading.gif" lazyload></p>
<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<blockquote>
<ol>
<li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<code>查询效率高</code>，因为不会发生回表，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li>
</ol>
</blockquote>
<h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：</p>
<ul>
<li>&#x3D;&#x3D;先把各个记录和页按照c2列进行排序。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;在记录的c2列相同的情况下，采用c3列进行排序&#x3D;&#x3D;</li>
</ul>
<p>为c2和c3建立的索引的示意图如下：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224918943.png" srcset="/img/loading.gif" lazyload alt="image-20230413224918943"></p>
<p>如图所示，我们需要注意以下几点：</p>
<ul>
<li>&#x3D;&#x3D;每条目录项都有c2、c3、页号这三个部分组成&#x3D;&#x3D;，<font color='red'>各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</font></li>
<li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<h3 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h3><h4 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h4><p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中即没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li>
<li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h4 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h4><p>我们知道B+树索引的内节点中目录项记录的内容是 <code>索引列 + 页号</code> 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224927795.png" srcset="/img/loading.gif" lazyload alt="image-20230413224927795"></p>
<p>如果二级索引中目录项记录的内容只是 <code>索引列 + 页号</code> 的搭配的话，那么为 <code>c2</code> 列简历索引后的B+树应该长这样：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224937295.png" srcset="/img/loading.gif" lazyload alt="image-20230413224937295"></p>
<p>如果我们想新插入一行记录，其中 <code>c1</code> 、<code>c2</code> 、<code>c3</code> 的值分别是: <code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 页号</code> 的值构成的，<code>页3</code> 中的两条目录项记录对应的 c2 列的值都是1，而我们 <code>新插入的这条记录</code> 的 c2 列的值也是 <code>1</code>，那我们这条新插入的记录到底应该放在 <code>页4</code> 中，还是应该放在 <code>页5</code> 中？答案：对不起，懵了</p>
<p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413224948100.png" srcset="/img/loading.gif" lazyload alt="image-20230413224948100"></p>
<p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code> 时，由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 主键 + 页号</code> 的值构成的，可以先把新纪录的 <code>c2</code> 列的值和 <code>页3</code> 中各目录项记录的 <code>c2</code> 列的值作比较，如果 <code>c2</code> 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 <code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 <code>页5</code> 中。</p>
<h4 id="3-一个页面最少存储-2-条记录"><a href="#3-一个页面最少存储-2-条记录" class="headerlink" title="3. 一个页面最少存储 2 条记录"></a>3. 一个页面最少存储 2 条记录</h4><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p>
<h2 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h2><p>B树索引使用存储引擎如表所示：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。</p>
<h3 id="4-1-MyISAM索引的原理"><a href="#4-1-MyISAM索引的原理" class="headerlink" title="4.1 MyISAM索引的原理"></a>4.1 MyISAM索引的原理</h3><p>我们知道InnoDB中索引即数据,也就是<code>聚簇索引</code>的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，<font color='red'>而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储</font>:</p>
<ul>
<li><p>将表中的记录按照记录的插入顺序单独存储在一 个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</p>
</li>
<li><p>使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM会单独为表的主键创建一个索引, |只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值+数据记录地址的组合。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225148668.png" srcset="/img/loading.gif" lazyload alt="image-20230413225148668"></p>
</li>
</ul>
<p>这里设表一共有三列, 假设我们以Col1为主键，上图是一 个MyISAM表的主索引(Primary key)示意。可以看出<br>MyISAM的素索引文件仅仅保存数据记录的地址。在MyISAM中， 主键索引和二级索引(Secondary key)在结构.上没<br>有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立-一个二级索<br>引，则此索引的结构如下图所示:</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225204209.png" srcset="/img/loading.gif" lazyload alt="image-20230413225204209"></p>
<p>同样也是一棵B+Tree, data域保存 数据记录的地址。因此，MyISAM中索弓 |检索的算法为:首先按照B+Tree搜索算法搜索索引，如果指定的Key存在,则取出其data域的值,然后以data域的值为地址，读取相应数据记录。</p>
<h3 id="4-2-MyISAM-与-InnoDB对比"><a href="#4-2-MyISAM-与-InnoDB对比" class="headerlink" title="4.2 MyISAM 与 InnoDB对比"></a>4.2 MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p>
<p><strong>两种引擎中索引的区别：</strong></p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 <code>聚簇索引</code> 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 <code>回表</code> 操作，意味着MyISAM中建立的索引相当于全部都是 <code>二级索引 </code>。</p>
<p>② &#x3D;&#x3D;InnoDB的数据文件本身就是索引文件，&#x3D;&#x3D;<font color='red'>而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。</font></p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 <code>主键的值</code> ，而MyISAM索引记录的是<code> 地址</code> 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>④ MyISAM的回表操作是十分 <code>快速 </code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通<code> 过获取主键之后再去聚簇索引里找记录</code>，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ InnoDB要求表 <code>必须有主键 </code>（ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<p><strong>小结：</strong></p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如:</p>
<p>举例1:知道了InnoDB的索引实现后，就很容易明白为什么<font color='red'>不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</font></p>
<p>举例2:<font color='red'>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree, 非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效,而使用自增字段作为主键则是一个很好的选择。</font></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225243011.png" srcset="/img/loading.gif" lazyload alt="image-20230413225243011"></p>
<h2 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p><strong>空间上的代价</strong></p>
<p>​		每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 <code>占用 16KB 的存储空间</code>，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p><strong>时间上的代价</strong></p>
<p>​		每次对表中的数据进行 <code>增、删、改</code> 操作时，都需要去修改各个B+树索引。而且我们讲过，<code>B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 </code>。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。<font color='red'>而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</font></p>
</li>
</ul>
<blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h2 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6. MySQL数据结构选择的合理性"></a>6. MySQL数据结构选择的合理性</h2><p>从MySQL的角度讲，不得不考虑一个现实问题就是磁盘10。 如果我们能让索引的数据结构尽量减少硬盘的1&#x2F;0操作，所消耗的时间也就越小。可以说， <code>磁盘的I/0操作次数</code>对索引的使用效率至关重要。</p>
<p>查找都是索引操作, -般来说索引非常大，尤其是关系型数据库,当数据量比较大的时候，索引的大小有可能几<br>个G甚至更多,为了减少索引在内存的占用，<code>数据库索引是存储在外部磁盘上的</code>。当我们利用索引查询的时候，<br>不可能把整个索引全部加载到内存，只能<code>逐一加载</code>，那么MySQL衡量查询效率的标准就是磁盘I0次数。</p>
<h3 id="6-1-全表查询"><a href="#6-1-全表查询" class="headerlink" title="6.1 全表查询"></a>6.1 全表查询</h3><p>全表遍历，全表查找。</p>
<h3 id="6-2-Hash查询"><a href="#6-2-Hash查询" class="headerlink" title="6.2 Hash查询"></a>6.2 Hash查询</h3><p>Hash本身是-个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p>
<p>Hash算法是通过某种确定性的算法(比如MD5、SHA1. SHA2、SHA3) 将输入转变为输出。<code>相同的输入永远可以 得到相同的输出</code>，假设输入内容有微小偏差,在输出中通常会有不同的结果。</p>
<p>举例:如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hash函数<br>计算得到的结果告诉你即可，然后在本地同样对文件进行Hash函数的运算，最后通过比较这两个Hash函数的结<br>果是否相同，就可以知道这两个文件是否相同。</p>
<p><strong>加快查找速度的数据结构，常见的有两类：</strong></p>
<p>(1) <strong>树</strong>，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(log2N)</code>;</p>
<p>(2)<strong>哈希</strong>，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(1)</code>; (key, value)</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225259592.png" srcset="/img/loading.gif" lazyload alt="image-20230413225259592"></p>
<p>采用Hash进行检索效率非常高,基本上-次检索就可以找到数据,而B+树需要自顶向下依次查找,多次访问节<br>点才能找到数据，中间需要多次1&#x2F;0操作，<code>从效率来说Hash比B+树更快</code>。</p>
<p>在哈希的方式下，-一个元素k处于h(k)中，即利用哈希函数h,根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表…m-1]的槽位上。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225330674.png" srcset="/img/loading.gif" lazyload alt="image-20230413225330674"></p>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 <code>碰撞 </code>，在数据库中一般采用 <code>链 接法 </code>来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225321713.png" srcset="/img/loading.gif" lazyload alt="image-20230413225321713"></p>
<p>实验：体会数组和hash表的查找方面的效率区别</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 算法复杂度为 O(n)</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"time： "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//time： 823</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 算法复杂度为 O(1)</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    	set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> contains <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"time： "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//time： 5</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></p>
<blockquote>
<ul>
<li>原因1: Hash 索引仅能满足(&#x3D;) (心) 和IN查询。如果进行<code>范围查询</code>，哈希型的索引,时间复杂度会退化为O(n);而树型的“有序”特性，依然能够保持0(log2N) 的高效率。</li>
<li>原因2: <font color='red'>Hash 索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</font></li>
<li>原因3:对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的, 无法对单独的一个键或者几个索引键进行查询。</li>
<li>原因4:对于等值查询来说,通常Hash索引的效率更高，不过也存在一种情况，就是<font color='red'>索引列的重复值如果很多，效率就会降低。</font>这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较,找到查询的关键字,非常耗时。所以，Hash 索引通常不会用到重复值多的列上,比如列为性别、年龄的情况等。</li>
</ul>
</blockquote>
<p><strong>Hash索引适用存储引擎如表所示：</strong></p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>HASH索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>Hash索引的适用性：</strong></p>
<p>Hash索引存在着很多限制，&#x3D;&#x3D;相比之下在数据库中B+树索引的使用面会更广，&#x3D;&#x3D;不过也有一些场景采用 Hash索引效率更高，比如在键值型(Key-Value) 数据库中，Redis 存储的核心就是Hash 表。</p>
<p>MySQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时,就可以选择Memory存储引<br>擎,把某个字段设置为Hash索引，比如字符串类型的字段,进行Hash计算之后长度可以缩短到几个字节。当字<br>段的重复度低，而且经常需要进行等值查询的时候，采用Hash索引是个不错的选择。</p>
<p>另外，InnoDB 本身不支持Hash索引，但是提供<code>自适应Hash索引(Adaptive Hash Index)</code>。什么情况下才会使用自适应Hash索引呢?如果某个数据经常被访问，当满足一定条件的时候, 就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225348300.png" srcset="/img/loading.gif" lazyload></p>
<p>&#x3D;&#x3D;采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。&#x3D;&#x3D;</p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%adaptive_hash_index'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>



<h3 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<p><strong>1. 二叉搜索树的特点</strong></p>
<blockquote>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li>
<li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点，比我大的向右，比我小的向左</li>
</ul>
</blockquote>
<p><strong>2. 查找规则</strong></p>
<p>我们先来看下最基础的二叉搜索树(Binary Search Tree)， 搜索某个节点和插入节点的规则一样,我们假设搜索<br>插入的数值为key:</p>
<ol>
<li>如果key大于根节点， 则在右子树中进行查找;</li>
<li>如果key 小于根节点，则在左子树中进行查找;</li>
<li>如果key 等于根节点，也就是找到了这个节点，返回根节点即可。</li>
</ol>
<p>举个例子，我们对数列(34, 22, 89, 5, 23, 77, 91) 创造出来的二分查找树如下图所示</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413191933729.png" srcset="/img/loading.gif" lazyload alt="image-20230413191933729"></p>
<p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413191948320.png" srcset="/img/loading.gif" lazyload alt="image-20230413191948320"></p>
<p>为了提高查询效率，就需要 <code>减少磁盘IO数</code> 。<font color='red'>为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</font></p>
<h3 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h3><p>为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树(Balanced Binary Tree) ，又称为<br>AVL树(有别于AVL算法) ,它在二叉搜索树的基础上增加了约束，具有以下性质:</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉树。</p>
<p>这里说一下，常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树、红黑树、 数堆、伸展树</code>。 平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上,第一棵树就属于平衡二叉搜索树，搜索<code>时间复杂度就是0(1og2n)</code>。</p>
<p>数据查询的时间主要依赖于磁盘1&#x2F;0的次数,如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改<br>进，树的深度也是0(log2n),当n比较大时，深度也是比较高的,比如下图的情况:</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225406081.png" srcset="/img/loading.gif" lazyload alt="image-20230413225406081"></p>
<p><code>每访问一次节点就需要进行一次磁盘 I/O 操作</code>，对于上面的树来说，我们需要进行 5次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225415974.png" srcset="/img/loading.gif" lazyload alt="image-20230413225415974"></p>
<p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把 <code>树从“瘦高” 变 “矮胖”</code>。</p>
<h3 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h3><p>B 树的英文是 Balance Tree，也就是 <code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225428350.png" srcset="/img/loading.gif" lazyload alt="image-20230413225428350"></p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>‘M称为B树的阶</code>。每个磁盘块中包括<br>了<code>关键字</code>和<code>子节点的指针</code>。如果一 个磁盘块中包括了x个关键字，那么指针数就是x+1。 对于一个100阶的B树<br>来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适<br>合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<blockquote>
<ol>
<li>根节点的儿子数的范围是 [2,M]。</li>
<li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ol>
</blockquote>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p>
<blockquote>
<ol>
<li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li>
<li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li>
<li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li>
</ol>
</blockquote>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p>
<p>小结:</p>
<blockquote>
<ol>
<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内做一次分查找。</li>
</ol>
</blockquote>
<p><strong>再举例1：</strong></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225439160.png" srcset="/img/loading.gif" lazyload alt="image-20230413225439160"></p>
<h3 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h3><p>B+树也是一种多路搜索树，<code>基于B树做出了改进</code>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比<br>于B-Tree，<code>B+Tree适合文件索引系统.</code></p>
<p><strong>B+ 树和 B 树的差异在于以下几点：</strong></p>
<blockquote>
<ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</li>
</ol>
</blockquote>
<p>下图就是一棵B+树,阶数为3,根节点中的关键字1. 18. 35 分别是子节点(1, 8, 14)，(18, 24, 31)和<br>(35, 41, 53) 中的最小值。每- -层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中<br>包括了所有的关键字信息，并且每一个叶子节点都有一 个指向下一个节点的指针,这样就形成了-个链表。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225541540.png" srcset="/img/loading.gif" lazyload alt="image-20230413225541540"></p>
<p>比如，我们想要查找关键字16, B+树会自顶向下逐层进行查找:</p>
<blockquote>
<ol>
<li>与根节点的关键字(1, 18, 35) 进行比较，16在1和18之间,得到指针P1 (指向磁盘块2)</li>
<li>找到磁盘块2,关键字为(1, 8, 14)，因为16大于14，所以得到指针P3 (指向磁盘块7)</li>
<li>找到磁盘块7,关键字为(14, 16, 17) ，然后我们找到了关键字16,所以可以找到关键字16所对应的据。</li>
</ol>
</blockquote>
<p>整个过程一共进行了3次I&#x2F;0操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在<br>于，B+ 树的中间节点并不直接存储数据。这样的好处都有什么呢?</p>
<blockquote>
<ol>
<li>首先，<code>B+树查询效率更稳定</code>。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</li>
<li>其次，<code>B+树的查询效率更高</code>。这是因为通常B+树比B树更矮胖(阶数更大, 深度更低),查询所需要的磁盘1&#x2F;0也会更少。同样的磁盘页大小, B+树可以存储更多的节点关键字。</li>
<li>不仅是对单个关键字的查询上，<code>在查询范围上, B+ 树的效率也比B树高</code>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</li>
</ol>
</blockquote>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>
<blockquote>
<ol>
<li>数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</li>
<li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</li>
</ol>
</blockquote>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<blockquote>
<p><code>InnoDB存储引擎中页的大小为16KB</code>，一般表的主键类型为INT (占用4个字节)或BIGINT (占用8个字<br>节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree 中的一个节点)中大概存储16KB&#x2F;8B+8B)&#x3D;1K个键值(因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为 3的B+Tree索引可以维护10^3 * 10^3* 10^3&#x3D; 10亿条记录。(这里假定一个数据页也存储10^3条行记录数据了)</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在2<del>4层。MySQL的<br>InnoDB存储引擎在设计时是<code>将根节点常驻内存</code>的，也就是说查找某一键值的行记录时最多只需要1</del>3次磁盘<br>1&#x2F;0操作。</p>
</blockquote>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<blockquote>
<ol>
<li><p><strong>B+树的磁盘读写代价更低</strong></p>
<p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说I&#x2F;O读写次数也就降低了。</p>
</li>
<li><p><strong>B+树的查询效率更加稳定</strong><br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ol>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<blockquote>
<ol>
<li><font color='red'>Hash 索引不能进行范围查询</font>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</li>
<li>Hash 索引不支持联合索引的最左侧原则(即联合索引的部分索引无法使用) ，而B+树可以。对于联合索引来说，Hash 索引在计算Hash值的时候是将索弓|键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用</li>
<li><font color='red'>Hash索引不支持ORDER BY排序</font>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作<br>用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE 后面后模糊查询(比如%结尾)的话就可以起到优化作用。</li>
<li><code>InnoDB 不支持哈希索引</code></li>
</ol>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong></p>
<blockquote>
<p>你能看到，针对<font color='red'>InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引</font>。InnoDB 提供<br>的自适应Hash是不需要手动指定的。如果是Memory&#x2F;Heap和NDB存储引擎，是可以进行选择Hash索引<br>的。</p>
</blockquote>
<h3 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h3><p>R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>R-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h3 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h3><p>&#x3D;&#x3D;使用索引可以帮助我们从海量的数据中快速定位想要查找的数据&#x3D;&#x3D;，<font color='red'>不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利(提升查询效率)和弊(维护索引所需的代价) 。</font></p>
<p>&#x3D;&#x3D;在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。&#x3D;&#x3D;</p>
<h3 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230413225603900.png" srcset="/img/loading.gif" lazyload alt="image-20230413225603900"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/MySQL/" class="category-chain-item">MySQL</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/">#MySQL</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第06章_索引的数据结构</div>
      <div>https://xhablog.online/2021/04/19/MySQL高级-第06章_索引的数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Xu huaiang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年4月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/20/MySQL%E9%AB%98%E7%BA%A7-%E7%AC%AC07%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" title="第07章_InnoDB数据存储结构">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第07章_InnoDB数据存储结构</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/18/MySQL%E9%AB%98%E7%BA%A7-%E7%AC%AC05%E7%AB%A0_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="第05章_存储引擎">
                        <span class="hidden-mobile">第05章_存储引擎</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"65685887a536577e68ad","clientSecret":"da9f0f4e5301326ac35bb6141f0234e2a7561f4c","repo":"sunwebgo.github.io","owner":"sunwebgo","admin":["sunwebgo"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '536b180c9979c668b1a005e38dd82efc'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span><svg t="1686650467734" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4406" width="13" height="13"><path d="M926.991 337.678c-22.571-53.364-54.877-101.283-96.021-142.426-41.143-41.143-89.062-73.449-142.426-96.02-55.266-23.375-113.953-35.228-174.434-35.228-60.48 0-119.168 11.852-174.433 35.228-53.364 22.571-101.283 54.877-142.426 96.02s-73.449 89.062-96.02 142.426c-23.375 55.265-35.228 113.953-35.228 174.433 0 60.48 11.852 119.168 35.228 174.434 22.571 53.364 54.877 101.283 96.02 142.426 41.143 41.144 89.062 73.449 142.426 96.021 55.265 23.375 113.953 35.228 174.433 35.228 60.48 0 119.168-11.853 174.434-35.228 53.364-22.571 101.283-54.877 142.426-96.021 41.144-41.143 73.449-89.062 96.021-142.426 23.375-55.266 35.228-113.953 35.228-174.434 0-60.48-11.853-119.168-35.228-174.433z m-412.88 558.541c-211.797 0-384.107-172.31-384.107-384.107 0-211.797 172.31-384.107 384.107-384.107 211.798 0 384.107 172.31 384.107 384.107 0.001 211.797-172.309 384.107-384.107 384.107z" p-id="4407"></path><path d="M514.111 290.829c51.918 0 102.431 18.428 142.233 51.889 13.528 11.375 33.715 9.626 45.086-3.902 11.373-13.527 9.626-33.713-3.902-45.086-51.316-43.142-116.456-66.901-183.417-66.901-76.201 0-147.842 29.675-201.725 83.557-53.883 53.883-83.558 125.523-83.558 201.725s29.675 147.843 83.558 201.726 125.523 83.558 201.725 83.558c66.961 0 132.1-23.76 183.417-66.901 13.528-11.372 15.275-31.559 3.902-45.086s-31.559-15.275-45.086-3.902c-39.803 33.462-90.315 51.89-142.233 51.89-122.015 0-221.282-99.268-221.282-221.283 0-122.017 99.267-221.284 221.282-221.284z" p-id="4408"></path></svg>2021 - 2023</span> <span>本站由</span> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>&</span> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <span>强力驱动</span> 
      <!--《添加网站运行时间 -->
<br/>

    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
      var now = new Date();

      function createtime() {
        //此处修改你的建站时间或者网站上线时间
        var grt = new Date('06/09/2023 8:00:00');
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;

        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
          hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
          mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
          snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = " 本站已破天荒的安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
      setInterval("createtime()", 250);
    </script>

<!-- 添加网站运行时间》-->
<br/>
<span style="font-weight: initial">文章总字数2164k</span>

    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
