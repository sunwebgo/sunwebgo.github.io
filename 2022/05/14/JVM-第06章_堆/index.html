

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/favicon.png">
  <link rel="icon" href="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Xu huaiang">
  <meta name="keywords" content="">
  
    <meta name="description" content="6.1. 堆（Heap）的核心概述在 JVM 中，堆是用于存储对象实例和数组的区域。   堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，进程中的多个线程共享同一堆空间的。 &#x3D;&#x3D;一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。&#x3D;&#x3D; &#x3D;&#x3D;Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="第06章_堆">
<meta property="og:url" content="https://xhablog.online/2022/05/14/JVM-%E7%AC%AC06%E7%AB%A0_%E5%A0%86/index.html">
<meta property="og:site_name" content="xhang′s blog">
<meta property="og:description" content="6.1. 堆（Heap）的核心概述在 JVM 中，堆是用于存储对象实例和数组的区域。   堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，进程中的多个线程共享同一堆空间的。 &#x3D;&#x3D;一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。&#x3D;&#x3D; &#x3D;&#x3D;Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/U6LRTMY%28VCAU0%281%60%29BK7LV1.png">
<meta property="article:published_time" content="2022-05-14T02:00:00.000Z">
<meta property="article:modified_time" content="2024-02-22T04:20:16.757Z">
<meta property="article:author" content="Xu huaiang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/U6LRTMY%28VCAU0%281%60%29BK7LV1.png">
  
  
  
  <title>第06章_堆 - xhang′s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">
<link rel="stylesheet" href="/css/iconfont.css">
<link rel="stylesheet" href="/css/indeximg-hover.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xhablog.online","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"giycfQfOF4KRyAqEJy6tocBG-gzGzoHsz","app_key":"eFPJSGrHpiDV2uq6UTxse15b","server_url":"https://giycfqfo.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>xhang′s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-zhuye"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-guidang1"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-fenlei"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-biaoqian"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/messageboard/">
                <i class="iconfont icon-liuyanban-05"></i>
                <span>留言板</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-youqinglianjie"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-guanyuwomen"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/hexo/index.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第06章_堆"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Xu huaiang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-14 10:00" pubdate>
          2022年5月14日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          112 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第06章_堆</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="6-1-堆（Heap）的核心概述"><a href="#6-1-堆（Heap）的核心概述" class="headerlink" title="6.1. 堆（Heap）的核心概述"></a>6.1. 堆（Heap）的核心概述</h2><p><strong><font color='scarlet'>在 JVM 中，堆是用于存储对象实例和数组的区域。</font></strong></p>
<blockquote>
<ul>
<li>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，<font color='scarlet'>进程中的多个线程共享同一堆空间的。</font></li>
<li>&#x3D;&#x3D;<strong>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</strong>。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。&#x3D;&#x3D;</li>
<li><font color='scarlet'>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</font></li>
<li><font color='scarlet'>所有的线程共享Java堆</font>。在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li><font color='red'>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</font></li>
<li>&#x3D;&#x3D;堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529105327331.png" srcset="/img/loading.gif" lazyload></p>
<p>​</p>
<h2 id="6-2-虚拟机栈、堆和方法区的关系"><a href="#6-2-虚拟机栈、堆和方法区的关系" class="headerlink" title="6.2. 虚拟机栈、堆和方法区的关系"></a>6.2. 虚拟机栈、堆和方法区的关系</h2><ul>
<li>虚拟机栈存储的是方法调用过程中的临时数据和调用者的地址信息。</li>
<li>堆存储对象和数组等数据。</li>
<li>方法区存储类信息、常量、静态变量等数据。</li>
</ul>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529111155865.png" srcset="/img/loading.gif" lazyload alt="image-20230529111155865"></p>
<h2 id="6-3-堆内存细分"><a href="#6-3-堆内存细分" class="headerlink" title="6.3. 堆内存细分"></a>6.3. 堆内存细分</h2><p>Java 7及之前堆内存逻辑上分为三部分：<code>新生代+老年代+永久代</code></p>
<p>Java 8及之后堆内存逻辑上分为三部分：<code>新生代+老年代+元空间</code></p>
<p>约定：&#x3D;&#x3D;新生区（代）&lt;&#x3D;&gt;年轻代 、 养老区&lt;&#x3D;&gt;老年区（代）、 永久区&lt;&#x3D;&gt;永久代&#x3D;&#x3D;</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529112532128.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6-4-堆内存设置和Visual-VM-虚拟机监视器"><a href="#6-4-堆内存设置和Visual-VM-虚拟机监视器" class="headerlink" title="6.4.堆内存设置和Visual VM(虚拟机监视器)"></a>6.4.堆内存设置和Visual VM(虚拟机监视器)</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<blockquote>
<ul>
<li><p>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></p>
</li>
<li><p>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></p>
</li>
</ul>
</blockquote>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出<code>OutOfMemoryError</code>异常。</p>
<p><font color='scarlet'>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了防止Java垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能。</font></p>
<p>默认情况下</p>
<blockquote>
<ul>
<li><p>初始内存大小：物理电脑内存大小 &#x2F; 64</p>
</li>
<li><p>最大内存大小：物理电脑内存大小 &#x2F; 4</p>
</li>
</ul>
</blockquote>
<ol>
<li>在<code>Configurations</code>设置堆内存大小</li>
</ol>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529121818461.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529122106046.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>启动main方法，并打开<code>Visual VM</code></li>
</ol>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529122203968.png" srcset="/img/loading.gif" lazyload alt="image-20230529122203968"></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529122301906.png" srcset="/img/loading.gif" lazyload alt="image-20230529122301906"></p>
<p>从下图可以看出：&#x3D;&#x3D;新生代+老年代一共20M&#x3D;&#x3D;</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529122840565.png" srcset="/img/loading.gif" lazyload alt="image-20230529122840565"></p>
<h2 id="6-5-堆内存OutOfMemory（堆内存溢出异常）"><a href="#6-5-堆内存OutOfMemory（堆内存溢出异常）" class="headerlink" title="6.5.堆内存OutOfMemory（堆内存溢出异常）"></a>6.5.堆内存OutOfMemory（堆内存溢出异常）</h2><p>由于堆内存中存储的是对象实例和数组，所以可以设置堆内存大小，并采用如下代码来使堆内存溢出。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529144212783.png" srcset="/img/loading.gif" lazyload alt="image-20230529144212783"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Practise08</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Picture</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Picture</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pixels<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pixels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/GIF%202023-5-29%2014-43-18.gif" srcset="/img/loading.gif" lazyload alt="GIF 2023-5-29 14-43-18"></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529144406403.png" srcset="/img/loading.gif" lazyload alt="image-20230529144406403"></p>
<h2 id="6-6-年轻代与老年代"><a href="#6-6-年轻代与老年代" class="headerlink" title="6.6. 年轻代与老年代"></a>6.6. 年轻代与老年代</h2><h3 id="6-6-1年轻代和老年代结构划分"><a href="#6-6-1年轻代和老年代结构划分" class="headerlink" title="6.6.1年轻代和老年代结构划分"></a>6.6.1年轻代和老年代结构划分</h3><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li><p>&#x3D;&#x3D;一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致&#x3D;&#x3D;</p>
</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>其中年轻代又可以划分为<code>Eden</code>区、<code>Survivor0</code>区和<code>Survivor1</code>区（有时也叫做from区、to区）</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529144830330.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-6-2年轻代和老年代的结构占比"><a href="#6-6-2年轻代和老年代的结构占比" class="headerlink" title="6.6.2年轻代和老年代的结构占比"></a>6.6.2年轻代和老年代的结构占比</h3><p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li><p>默认<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>
</li>
<li><p>可以修改<code>-XX:NewRatio=4</code>，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>
</li>
</ul>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529145612460.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-6-3年轻代中edeu区和survivor0、survivor1区结构占比"><a href="#6-6-3年轻代中edeu区和survivor0、survivor1区结构占比" class="headerlink" title="6.6.3年轻代中edeu区和survivor0、survivor1区结构占比"></a>6.6.3年轻代中edeu区和survivor0、survivor1区结构占比</h3><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，但是事实上却不是该比例，是由于<code>自适应策略</code>。</p>
<p>当然开发人员可以通过选项“<code>-xx:SurvivorRatio</code>”调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p>
<p><font color='scarlet'>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。</font></p>
<ul>
<li>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
</ul>
<p>可以使用选项”<code>-Xmn</code>“设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p>
<h2 id="6-7堆中对象的分配过程"><a href="#6-7堆中对象的分配过程" class="headerlink" title="6.7堆中对象的分配过程"></a>6.7堆中对象的分配过程</h2><h3 id="6-7-1堆中对象的分配的步骤"><a href="#6-7-1堆中对象的分配的步骤" class="headerlink" title="6.7.1堆中对象的分配的步骤"></a>6.7.1堆中对象的分配的步骤</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<blockquote>
<ol>
<li><p>new的对象先放入<code>Eden</code>区。此区有大小限制。</p>
</li>
<li><p>当<code>Eden</code>的空间填满时，程序又需要创建对象，<code>Young GC</code>将对<code>Eden</code>区进行垃圾回收（MinorGC），将<code>Eden</code>区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到<code>Eden</code>区</p>
</li>
<li><p>然后将<code>Eden</code>中的剩余对象移动到<code>survivor0</code>区，放入<code>survivor</code>区后对象的<code>年龄计数器</code>就会加1。</p>
</li>
<li><p>如果再次触发垃圾回收，将<code>Eden</code>区中继续使用的对象和上次幸存下来的放到<code>survivor0</code>区的，如果没有回收，就会都放到<code>survivor1</code>区。</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回<code>survivor0</code>区，接着再去<code>survivor1</code>区。</p>
</li>
<li><p>啥时候能去老年代呢？可以设置<code>年龄计数器</code>。默认是15次。</p>
</li>
</ol>
<ul>
<li><ul>
<li>可以设置参数：进行设置<code>-Xx:MaxTenuringThreshold= N</code></li>
</ul>
</li>
</ul>
<ol start="7">
<li><p>当老年代内存不足时，再次触发GC：Major GC，进行老年代的内存清理</p>
</li>
<li><p>若老年代执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</p>
</li>
</ol>
</blockquote>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529152048195.png" srcset="/img/loading.gif" lazyload></p>
<p>流程图如下：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529152337492.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>总结</strong></p>
<blockquote>
<ul>
<li><p>对于<code>survivor</code>当中的<code>from区</code>和<code>to区</code>是不固定的，当谁为空时，谁就是<code>to区</code>，<code>Eden区</code>中继续使用的对象就会放到<code>to</code>区。</p>
</li>
<li><p>当<code>survivor</code>区满的时候，不会触发垃圾回收机制。而<code>survivor</code>区的垃圾回收时跟随<code>Eden</code>区的垃圾回收进行的。</p>
</li>
<li><p>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</p>
</li>
</ul>
</blockquote>
<h3 id="6-7-1堆中对象分配的演示"><a href="#6-7-1堆中对象分配的演示" class="headerlink" title="6.7.1堆中对象分配的演示"></a>6.7.1堆中对象分配的演示</h3><ol>
<li>使用如下代码进行演示：</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Practise08</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Picture</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Picture</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pixels<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pixels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>可以发现下图5：</p>
<ol>
<li>当<code>Eden</code>区内存满后，<code>Yong GC</code>就会对其进行垃圾回收，将继续使用的对象存放在<code>survivor</code>区的<code>to</code>区。</li>
<li>对<code>Eden</code>区进行垃圾回收的同时，对<code>survivor</code>区也进行垃圾回收，将超过阈值（15次）的对象放入老年代。</li>
<li>当老年代内存满的时候就会出现<code>OutOfMemoryError</code>异常。</li>
</ol>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/GIF%202023-5-29%2016-17-57.gif" srcset="/img/loading.gif" lazyload></p>
<p>根据图表，对<code>堆中对象的分配过程</code>进行分析：</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529163609819.png" srcset="/img/loading.gif" lazyload alt="image-20230529163609819"></p>
<h2 id="6-5-Minor-GC，MajorGC、Full-GC"><a href="#6-5-Minor-GC，MajorGC、Full-GC" class="headerlink" title="6.5. Minor GC，MajorGC、Full GC"></a>6.5. Minor GC，MajorGC、Full GC</h2><h3 id="6-5-1Minor-GC，MajorGC、Full-GC的区别"><a href="#6-5-1Minor-GC，MajorGC、Full-GC的区别" class="headerlink" title="6.5.1Minor GC，MajorGC、Full GC的区别"></a>6.5.1Minor GC，MajorGC、Full GC的区别</h3><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指<code>新生代</code>。</p>
<p>针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：<font color='scarlet'>一种是部分收集（Partial GC）</font>，<font color='cornflowerblue'>一种是整堆收集（FullGC）</font></p>
<blockquote>
<ul>
<li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><p><strong>新生代收集</strong>（Minor GC &#x2F; Young GC）：<font color='scarlet'>只是新生代的垃圾收集</font></p>
</li>
<li><p><strong>老年代收集</strong>（Major GC &#x2F; Old GC）：<font color='scarlet'>只是老年代的垃圾收集。 </font></p>
<ul>
<li><p>目前，只有CMSGC会有单独收集老年代的行为。</p>
</li>
<li><p>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</p>
</li>
</ul>
</li>
<li><p><strong>混合收集</strong>（MixedGC）：<font color='scarlet'>收集整个新生代以及部分老年代的垃圾收集。 </font></p>
</li>
<li><p>目前，只有G1 GC会有这种行为</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>整堆收集（Full GC）：<font color='scarlet'>收集整个java堆和方法区的垃圾收集。</font></li>
</ul>
</blockquote>
<h3 id="6-5-1-GC策略的触发条件"><a href="#6-5-1-GC策略的触发条件" class="headerlink" title="6.5.1. GC策略的触发条件"></a>6.5.1. GC策略的触发条件</h3><h4 id="6-5-1-1年轻代GC（Minor-GC）触发机制"><a href="#6-5-1-1年轻代GC（Minor-GC）触发机制" class="headerlink" title="6.5.1.1年轻代GC（Minor GC）触发机制"></a>6.5.1.1年轻代GC（Minor GC）触发机制</h4><ul>
<li><p><font color='red'> 当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。</font>（每次Minor GC会清理年轻代的内存。） </p>
</li>
<li><p>因为Java对象大多都具备朝生夕灭的特性.，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
</li>
<li><p><strong><font color='scarlet'>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</font></strong></p>
</li>
</ul>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230529184110448.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-5-1-2老年代GC（Major-GC）触发机制"><a href="#6-5-1-2老年代GC（Major-GC）触发机制" class="headerlink" title="6.5.1.2老年代GC（Major GC）触发机制"></a>6.5.1.2老年代GC（Major GC）触发机制</h4><ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了</li>
<li>出现了Major Gc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）<ul>
<li><font color='scarlet'>也就是在老年代空间不足时，会先尝试触发Minor Gc。如果之后空间还不足，则触发Major GC</font></li>
</ul>
</li>
<li><font color='red'>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长 </font></li>
<li>如果Major GC后，内存还不足，就报OOM了</li>
</ul>
<h4 id="6-5-1-3Full-GC触发机制（后面细讲）："><a href="#6-5-1-3Full-GC触发机制（后面细讲）：" class="headerlink" title="6.5.1.3Full GC触发机制（后面细讲）："></a>6.5.1.3Full GC触发机制（后面细讲）：</h4><p>触发Full GC执行的情况有如下五种：</p>
<blockquote>
<ol>
<li><p>调用System.gc()时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足（JDK1.7及之前的永久代内存不足）</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
</li>
<li><p>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
</li>
</ol>
</blockquote>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样<code>用户线程</code>暂时时间会短一些</p>
<h3 id="6-5-2案例演示GC的回收情况"><a href="#6-5-2案例演示GC的回收情况" class="headerlink" title="6.5.2案例演示GC的回收情况"></a>6.5.2案例演示GC的回收情况</h3><ol>
<li>代码如下</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Practise09</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                a <span class="token operator">=</span> a <span class="token operator">+</span> a<span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"遍历次数："</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<ol start="2">
<li>配置JVM参数</li>
</ol>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230530092336211.png" srcset="/img/loading.gif" lazyload alt="image-20230530092336211"></p>
<ol start="3">
<li>查看GC日志</li>
</ol>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230530093227789.png" srcset="/img/loading.gif" lazyload alt="image-20230530093227789"></p>
<h2 id="6-6-堆空间分代思想"><a href="#6-6-堆空间分代思想" class="headerlink" title="6.6. 堆空间分代思想"></a>6.6. 堆空间分代思想</h2><p><font color='red'>为什么要把Java堆分代？不分代就不能正常工作了吗？</font></p>
<p>经研究，不同对象的生命周期不同。&#x3D;&#x3D;70%-99%的对象是临时对象。&#x3D;&#x3D;</p>
<ul>
<li><p>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to，s0&#x2F;s1）构成，to总为空。</p>
</li>
<li><p>老年代：存放新生代中经历多次GC仍然存活的对象。</p>
</li>
</ul>
<p>其实不分代完全可以，**<font color='scarlet'>分代的唯一理由就是优化GC性能</font>**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230530093355913.png" srcset="/img/loading.gif" lazyload alt="image-20230530093355913"></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230530093405647.png" srcset="/img/loading.gif" lazyload alt="image-20230530093405647"></p>
<h2 id="6-7-内存分配策略"><a href="#6-7-内存分配策略" class="headerlink" title="6.7. 内存分配策略"></a>6.7. 内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象的<code>年龄计数器</code>设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。</p>
<p>对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<blockquote>
<ul>
<li><p><font color='scarlet'>优先分配到Eden</font></p>
</li>
<li><p><font color='scarlet'>大对象直接分配到老年代</font>（<font color='red'>尽量避免程序中出现过多的大对象</font>）</p>
</li>
<li><p><font color='scarlet'>长期存活的对象分配到老年代</font></p>
</li>
<li><p><font color='scarlet'>动态对象年龄判断</font>：如果survivor区中年龄从小到大的对象占据的空间，大于survivor区域的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。最后取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。</p>
</li>
<li><p>空间分配担保： <code>-XX:HandlePromotionFailure</code></p>
</li>
<li><p>空间分配担保是为了确保老年代当中有足够的连续内存用于存储在发生Minor GC时，年轻代中的所有对象都存活的情况。</p>
</li>
<li><p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
</li>
</ul>
</blockquote>
<h2 id="6-8-为对象分配内存：TLAB"><a href="#6-8-为对象分配内存：TLAB" class="headerlink" title="6.8. 为对象分配内存：TLAB"></a>6.8. 为对象分配内存：TLAB</h2><h3 id="6-8-1-为什么有TLAB"><a href="#6-8-1-为什么有TLAB" class="headerlink" title="6.8.1. 为什么有TLAB"></a>6.8.1. 为什么有TLAB</h3><ul>
<li><p><font color='scarlet'>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 </font></p>
</li>
<li><p><font color='scarlet'> 由于对象实例的创建在JVM中非常频繁，因此&#x3D;&#x3D;在并发环境下多个线程从堆区中划分内存空间是线程不安全的&#x3D;&#x3D; </font></p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
</li>
</ul>
<h3 id="6-8-2-什么是TLAB？"><a href="#6-8-2-什么是TLAB？" class="headerlink" title="6.8.2. 什么是TLAB？"></a>6.8.2. 什么是TLAB？</h3><ul>
<li>TLAB：Thread Local Allocation Buffer，即<code>线程分配缓冲区</code></li>
</ul>
<ul>
<li><p><font color='scarlet'> 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有<code>缓存区域</code>，它包含在Eden空间内。 </font></p>
</li>
<li><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
</li>
<li><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
</li>
</ul>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230530094824299.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-8-3-TLAB的再说明"><a href="#6-8-3-TLAB的再说明" class="headerlink" title="6.8.3. TLAB的再说明"></a>6.8.3. TLAB的再说明</h3><ul>
<li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>
</li>
<li><p>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启TLAB空间。</p>
</li>
<li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 “<code>-XX:TLABWasteTargetPercent</code>” 设置TLAB空间所占用Eden空间的百分比大小。</p>
</li>
<li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
</li>
</ul>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230530095341803.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6-9-小结：堆空间的参数设置"><a href="#6-9-小结：堆空间的参数设置" class="headerlink" title="6.9. 小结：堆空间的参数设置"></a>6.9. 小结：堆空间的参数设置</h2><p>官网地址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintFlagsInitial</span>  <span class="token comment">//查看所有的参数的默认初始值</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintFlagsFinal</span>  <span class="token comment">//查看所有的参数的最终值（可能会存在修改，不再是初始值）</span>
<span class="token operator">-</span><span class="token class-name">Xms</span>  <span class="token comment">//初始堆空间内存（默认为物理内存的1/64）</span>
<span class="token operator">-</span><span class="token class-name">Xmx</span>  <span class="token comment">//最大堆空间内存（默认为物理内存的1/4）</span>
<span class="token operator">-</span><span class="token class-name">Xmn</span>  <span class="token comment">//设置新生代的大小。（初始值及最大值）</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">NewRatio</span>  <span class="token comment">//配置新生代与老年代在堆结构的占比</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">SurvivorRatio</span>  <span class="token comment">//设置新生代中Eden和S0/S1空间的比例</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxTenuringThreshold</span>  <span class="token comment">//设置新生代垃圾的最大年龄</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGCDetails</span> <span class="token comment">//输出详细的GC处理日志</span>
<span class="token comment">//打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">HandlePromotionFalilure</span>：<span class="token comment">//是否设置空间分配担保</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<ul>
<li><p>如果大于，则此次Minor GC是安全的</p>
</li>
<li><p>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。</p>
<ul>
<li><p>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</p>
<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次Full GC。</li>
</ul>
</li>
<li><p>如果<code>HandlePromotionFailure=false</code>，则改为进行一次Full Gc。</p>
</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的<code>空间分配担保策略</code>，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为&#x3D;&#x3D;只要老年代的<code>连续空间大于新生代对象总大小</code>或者<code>历次晋升的平均大小</code>就会进行Minor GC&#x3D;&#x3D;，<font color='scarlet'>否则将进行FullGC</font>。</p>
<h2 id="6-10-对象的堆外存储技术"><a href="#6-10-对象的堆外存储技术" class="headerlink" title="6.10. 对象的堆外存储技术"></a>6.10. 对象的堆外存储技术</h2><h3 id="6-10-1堆外存储技术概述"><a href="#6-10-1堆外存储技术概述" class="headerlink" title="6.10.1堆外存储技术概述"></a>6.10.1堆外存储技术概述</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，<font color='scarlet'>那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</font>。&#x3D;&#x3D;这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。&#x3D;&#x3D;</p>
<h3 id="6-10-2-逃逸分析概述"><a href="#6-10-2-逃逸分析概述" class="headerlink" title="6.10.2. 逃逸分析概述"></a>6.10.2. 逃逸分析概述</h3><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>&#x3D;&#x3D;这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。&#x3D;&#x3D;</p>
<p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><p><font color='scarlet'>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，则认为没有发生逃逸。</font></p>
</li>
<li><p><font color='scarlet'>当一个对象在方法中被定义后，<strong>它被外部方法所引用</strong>，则认为发生逃逸。例如作为调用参数传递到其他地方中。</font></p>
</li>
</ul>
<p><strong>举例1</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">my_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">V</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// use v</span>
    <span class="token comment">// ....</span>
    v <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StringBuffer</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>举例2</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EscapeAnalysis</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token class-name">EscapeAnalysis</span> obj<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 方法返回EscapeAnalysis对象，发生逃逸
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">EscapeAnalysis</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> obj <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">EscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 为成员属性赋值，发生逃逸
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 引用成员变量的值，发生逃逸
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useEscapeAnalysis2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">EscapeAnalysis</span> e <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">/**
     * 对象的作用于仅在当前方法中有效，没有发生逃逸
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useEscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">EscapeAnalysis</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>参数设置</strong></p>
<p>在JDK 6u23 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
<p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li><p>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</p>
</li>
<li><p>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</p>
</li>
</ul>
<p><strong>结论</strong>：<font color='scarlet'>开发中能使用局部变量的，就不要使用在方法外定义</font>。</p>
<h3 id="6-10-3-通过逃逸分析对代码优化"><a href="#6-10-3-通过逃逸分析对代码优化" class="headerlink" title="6.10.3. 通过逃逸分析对代码优化"></a>6.10.3. 通过逃逸分析对代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<blockquote>
<p>一、栈上分配：<font color='scarlet'>将堆分配转化为栈分配</font>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p>
<p>二、同步省略<font color='scarlet'>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</font></p>
<p>三、标量替换(分离对象)：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
</blockquote>
<h4 id="6-10-3-1栈上分配"><a href="#6-10-3-1栈上分配" class="headerlink" title="6.10.3.1栈上分配"></a>6.10.3.1栈上分配</h4><p>&#x3D;&#x3D;JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。&#x3D;&#x3D;<font color='scarlet'>分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</font></p>
<p><strong>常见的栈上分配的场景</strong></p>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>
<p>案例：</p>
<ol>
<li><strong><font color='scarlet'>查看创建对象数量</font></strong></li>
</ol>
<p>设置堆内存大小为1GB，不做逃逸分析，打印GC的详细信息</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603100245229.png" srcset="/img/loading.gif" lazyload alt="image-20230603100245229"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Practise12</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cost time "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>可以看出在堆内存当中就是存在1000000个User对象。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603100842743.png" srcset="/img/loading.gif" lazyload alt="image-20230603100842743"></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603100631994.png" srcset="/img/loading.gif" lazyload alt="image-20230603100631994"></p>
<p>开启逃逸分析后查看</p>
<p>此时就没有产生1000000个对象，花费时间更少。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603100949666.png" srcset="/img/loading.gif" lazyload alt="image-20230603100949666"></p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603100939218.png" srcset="/img/loading.gif" lazyload alt="image-20230603100939218"></p>
<ol start="2">
<li><strong><font color='scarlet'>查询GC的执行情况</font></strong></li>
</ol>
<p>设置堆内存大小为256m，不做逃逸分析，打印GC的详细信息</p>
<p>可以看到当堆内存太小时，在不进行逃逸分析的情况下，就会在年轻代就是触发Yonug GC。</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603102852413.png" srcset="/img/loading.gif" lazyload alt="image-20230603102852413"></p>
<p>开启逃逸分析后查看</p>
<p>没有进行GC</p>
<p><img src="https://imagebed-xuhuaiang.oss-cn-shanghai.aliyuncs.com/typora/image-20230603103038961.png" srcset="/img/loading.gif" lazyload alt="image-20230603103038961"></p>
<h4 id="6-10-2-2同步省略"><a href="#6-10-2-2同步省略" class="headerlink" title="6.10.2.2同步省略"></a>6.10.2.2同步省略</h4><p><font color='scarlet'>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</font></p>
<p>&#x3D;&#x3D;在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步代码块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程（即此对象只在该方法中被引用）。&#x3D;&#x3D;<font color='red'>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</font></p>
<p><strong>举例</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Object</span> hellis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Object</span> hellis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h4 id="6-10-2-3标量替换-对象分离"><a href="#6-10-2-3标量替换-对象分离" class="headerlink" title="6.10.2.3标量替换(对象分离)"></a>6.10.2.3标量替换(对象分离)</h4><p>&#x3D;&#x3D;标量（scalar）是指一个无法再分解成更小的数据的数据。&#x3D;&#x3D;Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做<code>聚合量（Aggregate）</code>，<font color='scarlet'>Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</font></p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界引用的话，那么经过JIT优化，就会把这个对象拆解成若干个包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<p><strong>举例</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Point</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"point.x"</span> <span class="token operator">+</span> point<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">";point.y"</span> <span class="token operator">+</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    privat <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>以上代码，经过标量替换后，就会变成</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"point.x = "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"; point.y="</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。&#x3D;&#x3D;那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。&#x3D;&#x3D;</p>
<p><strong>标量替换参数设置</strong></p>
<p>参数<code>-XX:EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配到栈上。</p>
<p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-server</span> <span class="token parameter variable">-Xmx100m</span> <span class="token parameter variable">-Xms100m</span> <span class="token parameter variable">-XX:+DoEscapeAnalysis</span> <span class="token parameter variable">-XX:+PrintGC</span> <span class="token parameter variable">-XX:+EliminateAllocations</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>这里设置参数如下：</p>
<ul>
<li><p>参数<code>-server</code>：启动Server模式，因为在server模式下，才可以启用逃逸分析。</p>
</li>
<li><p>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</p>
</li>
<li><p>参数<code>-Xmx10m</code>：指定了堆空间最大为10MB</p>
</li>
<li><p>参数<code>-XX:+PrintGC</code>：将打印Gc日志</p>
</li>
<li><p>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</p>
</li>
</ul>
<h3 id="6-X-3-逃逸分析小结：逃逸分析并不成熟"><a href="#6-X-3-逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="6.X.3. 逃逸分析小结：逃逸分析并不成熟"></a>6.X.3. 逃逸分析小结：逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p>
<p>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>
<h2 id="6-11-本章小结"><a href="#6-11-本章小结" class="headerlink" title="6.11.本章小结"></a>6.11.本章小结</h2><p>&#x3D;&#x3D;年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。&#x3D;&#x3D;</p>
<p>老年代放置长生命周期的对象，通常都是从<code>survivor</code>区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB（线程分配缓冲区）上；如果对象较大，JVM会试图直接分配在Eden其他位置上；<font color='scarlet'>如果对象太大，完全无法在年轻代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</font>&#x3D;&#x3D;当GC只发生在年轻代中，回收年轻代对象的行为被称为<code>MinorGc</code>。&#x3D;&#x3D;</p>
<p>当GC发生在老年代时则被称为<code>MajorGc</code>或者<code>FullGC</code>。一般的，<code>MinorGc</code>的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JVM/" class="category-chain-item">JVM</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/JVM/">#JVM</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第06章_堆</div>
      <div>https://xhablog.online/2022/05/14/JVM-第06章_堆/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Xu huaiang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/15/JVM-%E7%AC%AC07%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA/" title="第07章_方法区">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第07章_方法区</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/13/JVM-%E7%AC%AC05%E7%AB%A0_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/" title="第05章_本地方法栈">
                        <span class="hidden-mobile">第05章_本地方法栈</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"65685887a536577e68ad","clientSecret":"da9f0f4e5301326ac35bb6141f0234e2a7561f4c","repo":"sunwebgo.github.io","owner":"sunwebgo","admin":["sunwebgo"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '77894adc7fb5dca989f5a6b0800ac48e'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span><svg t="1686650467734" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4406" width="13" height="13"><path d="M926.991 337.678c-22.571-53.364-54.877-101.283-96.021-142.426-41.143-41.143-89.062-73.449-142.426-96.02-55.266-23.375-113.953-35.228-174.434-35.228-60.48 0-119.168 11.852-174.433 35.228-53.364 22.571-101.283 54.877-142.426 96.02s-73.449 89.062-96.02 142.426c-23.375 55.265-35.228 113.953-35.228 174.433 0 60.48 11.852 119.168 35.228 174.434 22.571 53.364 54.877 101.283 96.02 142.426 41.143 41.144 89.062 73.449 142.426 96.021 55.265 23.375 113.953 35.228 174.433 35.228 60.48 0 119.168-11.853 174.434-35.228 53.364-22.571 101.283-54.877 142.426-96.021 41.144-41.143 73.449-89.062 96.021-142.426 23.375-55.266 35.228-113.953 35.228-174.434 0-60.48-11.853-119.168-35.228-174.433z m-412.88 558.541c-211.797 0-384.107-172.31-384.107-384.107 0-211.797 172.31-384.107 384.107-384.107 211.798 0 384.107 172.31 384.107 384.107 0.001 211.797-172.309 384.107-384.107 384.107z" p-id="4407"></path><path d="M514.111 290.829c51.918 0 102.431 18.428 142.233 51.889 13.528 11.375 33.715 9.626 45.086-3.902 11.373-13.527 9.626-33.713-3.902-45.086-51.316-43.142-116.456-66.901-183.417-66.901-76.201 0-147.842 29.675-201.725 83.557-53.883 53.883-83.558 125.523-83.558 201.725s29.675 147.843 83.558 201.726 125.523 83.558 201.725 83.558c66.961 0 132.1-23.76 183.417-66.901 13.528-11.372 15.275-31.559 3.902-45.086s-31.559-15.275-45.086-3.902c-39.803 33.462-90.315 51.89-142.233 51.89-122.015 0-221.282-99.268-221.282-221.283 0-122.017 99.267-221.284 221.282-221.284z" p-id="4408"></path></svg>2021 - 2023</span> <span>本站由</span> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>&</span> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <span>强力驱动</span> 
      <!--《添加网站运行时间 -->
<br/>

    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
      var now = new Date();

      function createtime() {
        //此处修改你的建站时间或者网站上线时间
        var grt = new Date('06/09/2023 8:00:00');
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;

        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
          hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
          mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
          snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = " 本站已破天荒的安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
      setInterval("createtime()", 250);
    </script>

<!-- 添加网站运行时间》-->
<br/>
<span style="font-weight: initial">文章总字数2739k</span>

    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
